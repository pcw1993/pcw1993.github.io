[{"title":"ImportError: libsybdb.so.5: cannot open shared object file: No such file or directory","url":"/2019/04/26/ImportError-libsybdb-so-5-cannot-open-shared-object-file-No-such-file-or-directory/","content":"\n##### 遇到的问题\n\n##### ImportError: libsybdb.so.5\n\n今天安装pymssql，众所周知，这个库依赖FreeTDS，所以我通过下载源码的方式安装了它，但问题也出现了，运行后报了以下错误\n\n```\nImportError: libsybdb.so.5: cannot open shared object file: No such file or\n  directory\n```\n\n这让我很苦恼，本来对linux系统就不是特别熟悉，多方查阅资料，搜索技术博客。很多人写的都不能解决我的问题。直到后来，这里不得不说说搜索引擎的影响了。同样的搜索条件，百度给的大多是百度知道，新浪博客和一些不知道什么奇奇怪怪的一大堆广告的类似于CSDN这种博客或者学习网站的结果，这很影响心情！！！还是用了谷歌，令人欣慰，结果大都来自知名的github，或者Stack Overflow。看起来很靠谱，没想到，结果也很靠谱！\n\n\n\n### 解决\n\n分析原因为使用源码安装FreeTDS时，其产生的文件也在自己指定的文件夹中，这就导致程序不一定能找到它。从而导致 ImportError！症结所在找到了，解决自然就比较流畅了，最方便的方法，创建软连接，使用`sudo find /  -name libsybdb.so.5`找到我的**libsybdb.so.5**文件坐在位置比如，我的文件在`/home/pcw/Downloads/freetds-0.91/src/dblib/.libs/libsybdb.so.5`使用命令创建软链接 \n\n```\nsudo ln -s /home/pcw/Downloads/freetds-0.91/src/dblib/.libs/libsybdb.so.5 /usr/lib/libsybdb.so.5\n```\n\n当然，你需要把路径换成你自己的！\n\n"},{"title":"mac终端切换用户","url":"/2019/04/03/mac终端切换用户/","content":"\n#### 1、mac终端切换用户到root\n\nsudo -i 即可\n\n#### 2、mac终端切换成普通用户\n\nsu - test（test为用户名）即可\n\n#### 3、mac可以设置命令别名\n\n如ll，正常情况下，mac终端不识别ll命令，但是alias 命令设置别名后，终端即可以设别ll命令：alias ll='ls -la'；但是没有修改系统文件，则该命令只能临时生效，下次再打开终端，还是不能识别ll命令，永久生效办法，请修改系统文件，方法有多种，请自行百度（如果不是ll命令，其他命令同理）\n\n","tags":["Mac"]},{"title":"mac设置环境变量PATH","url":"/2019/04/03/mac设置环境变量PATH/","content":"\n## 理论篇\n\nMac系统的环境变量，加载顺序为：\n\n/etc/profile \n\n/etc/paths \n\n~/.bash_profile \n\n~/.bash_login \n\n~/.profile \n\n~/.bashrc\n\n/etc/profile和/etc/paths是系统级别的，系统启动就会加载，后面几个是当前用户级的环境变量。后面3个按照从前往后的顺序读取，如果/.bash_profile文件存在，则后面的几个文件就会被忽略不读了，如果/.bash_profile文件不存在，才会以此类推读取后面的文件。~/.bashrc没有上述规则，它是bash shell打开的时候载入的。\n\nPATH的语法为如下\n\n```bash\n#中间用冒号隔开\nexport PATH=$PATH:<PATH 1>:<PATH 2>:<PATH 3>:------:<PATH N>\n```\n\n\n\n### 上述文件的科普\n\n- /etc/paths （全局建议修改这个文件 ）\n   编辑 paths，将环境变量添加到 paths文件中 ，一行一个路径\n   Hint：输入环境变量时，不用一个一个地输入，只要拖动文件夹到 Terminal 里就可以了。\n- /etc/profile （建议不修改这个文件 ）\n   全局（公有）配置，不管是哪个用户，登录时都会读取该文件。\n- /etc/bashrc （一般在这个文件中添加系统级环境变量）\n   全局（公有）配置，bash shell执行时，不管是何种方式，都会读取此文件\n- .profile 文件为系统的每个用户设置环境信息,当用户第一次登录时,该文件被执行.并从/etc/profile.d目录的配置文件中搜集shell的设置\n   **使用注意**：如果你有对/etc/profile有修改的话必须得重启你的修改才会生效，此修改对每个用户都生效。\n- ./bashrc 每一个运行bash shell的用户执行此文件.当bash shell被打开时,该文件被读取.\n   **使用注意** 对所有的使用bash的用户修改某个配置并在以后打开的bash都生效的话可以修改这个文件，修改这个文件不用重启，重新打开一个bash即可生效。\n- ./bash_profile 该文件包含专用于你的bash shell的bash信息,当登录时以及每次打开新的shell时,该文件被读取.（每个用户都有一个.bashrc文件，在用户目录下）\n   **使用注意** 需要需要重启才会生效，/etc/profile对所有用户生效，~/.bash_profile只对当前用户生效。\n\nsource ./.bash_profile 或者 ./.profile 环境信息生效\n\n\n\n## 操作篇\n\n### 全局设置\n\n创建一个文件：\n\n```bash\nsudo touch /etc/paths.d/mysql\n```\n\n用 vim 打开这个文件（如果是以 open -t 的方式打开，则不允许编辑）：\n\n```bash\nsudo vim /etc/paths.d/mysql\n```\n\n编辑该文件，键入路径并保存（关闭该 Terminal 窗口并重新打开一个，就能使用 mysql 命令了）\n\n```\n/usr/local/mysql/bin\n```\n\n$ source 相应的文件 生效配置环境\n\n\n\n### 单个用户设置\n\ncd ~\n\nvim ~/.bash_profile （任意一个文件中添加用户级环境变量）\n\n```\nexport PATH=/opt/local/bin:/opt/local/sbin:$PATH\n```\n\n把上述代码添加到~/.bash_profile上。\n\nsource 相应的文件 生效配置环境\n\n\n\n### 查看PATH\n\n```bash\necho $PATH\n```","tags":["Mac"]},{"title":"python使用schedule定时任务","url":"/2019/04/03/python使用schedule定时任务/","content":"\n\n\n### python中的轻量级定时任务调度库：schedule\n\n定时任务可以使用celery或crontab等，Python中有一个轻量级的定时任务调度的库：schedule。\n\n\n\n#### 安装\n\npip install schedule\n\n\n\n#### 简单例子\n\n```python\nimport schedule\nimport time\n \ndef job():\n    print(\"I'm working...\")\n \nschedule.every(10).minutes.do(job)\nschedule.every().hour.do(job)\nschedule.every().day.at(\"10:30\").do(job)\nschedule.every(5).to(10).days.do(job)\nschedule.every().monday.do(job)\nschedule.every().wednesday.at(\"13:15\").do(job)\n \nwhile True:\n    schedule.run_pending()\n    time.sleep(1)\n```\n\n\n\n#### 多任务运行\n\n```python\nimport datetime\nimport schedule\nimport time\n \ndef job1():\n    print(\"I'm working for job1\")\n    time.sleep(2)\n    print(\"job1:\", datetime.datetime.now())\n \ndef job2():\n    print(\"I'm working for job2\")\n    time.sleep(2)\n    print(\"job2:\", datetime.datetime.now())\n \ndef run():\n    schedule.every(10).seconds.do(job1)\n    schedule.every(10).seconds.do(job2)\n \n    while True:\n        schedule.run_pending()\n        time.sleep(1)\n\n        \nif __name__ == '__main__':\n    run()\n```\n\n\n\n由于上面这种方法会导致job2运行延迟，所以这时候需要使用多线程运行。\n\n#### 多线程运行\n\n```python\nimport datetime\nimport schedule\nimport threading\nimport time\n \ndef job1():\n    print(\"I'm working for job1\")\n    time.sleep(2)\n    print(\"job1:\", datetime.datetime.now())\n \ndef job2():\n    print(\"I'm working for job2\")\n    time.sleep(2)\n    print(\"job2:\", datetime.datetime.now())\n \ndef job1_task():\n    threading.Thread(target=job1).start()\n \ndef job2_task():\n    threading.Thread(target=job2).start()\n \ndef run():\n    schedule.every(10).seconds.do(job1_task)\n    schedule.every(10).seconds.do(job2_task)\n \n    while True:\n        schedule.run_pending()\n        time.sleep(1)\n        \n        \nif __name__ == '__main__':\n    run()\n```\n\n","tags":["Python"]},{"title":"Python实现RPC微型服务器","url":"/2019/04/02/Python实现RPC微型服务器/","content":"\n## RPC\n\n先说说什么是RPC，RPC（Remote Procedure Call）——远程过程调用，它是一种通过网络从远程计算机程序上请求服务，而不需要了解底层网络技术的协议。RPC协议假定某些传输协议的存在，如TCP或UDP，为通信程序之间携带信息数据。在OSI网络通信模型中，RPC跨越了传输层和应用层。RPC使得开发包括网络分布式多程序在内的应用程序更加容易。\n\nRPC采用客户机/服务器模式。请求程序就是一个客户机，而服务提供程序就是一个服务器。首先，客户机调用进程发送一个有进程参数的调用信息到服务进程，然后等待应答信息。在服务器端，进程保持睡眠状态直到调用信息到达为止。当一个调用信息到达，服务器获得进程参数，计算结果，发送答复信息，然后等待下一个调用信息，最后，客户端调用进程接收答复信息，获得进程结果，然后调用执行继续进行。\n\n说白了，就是一种远程调用函数接口的方式，客户端和服务端之间约定一种契约（函数接口），然后服务端一直等待客户端的调用。有点像平常的WEB网络请求，不过这种方式非常轻量，不涉及HTTP这些东西，待会可以看到实现很简单。\n\n上面说了，一种用途是在多台服务器之间互相进行调用，另一个用途则在于，不同编程语言之间都支持这种方式，像Python更是内置对其的支持，不需要额外安装什么库，所以可以直接在多语言的服务器之间互相进行调用，很简单。\n\n## xmlrpc库\n\n在Python2（网上大部分是Python2使用RPC的资料）中，服务端需要用到SimpleXMLRPCServer库，客户端需要用到ServerProxy库，而在Python3中，两者被整合到了同一个[xmlrpc库](https://docs.python.org/3/library/xmlrpc.html)中，分为xmlrpc.server和xmlrpc.client两部分。所以如果在Python3下使用，就需要导入这个库了。\n\n\n\n### 简单版\n\n- 服务器端\n\n```python\nfrom xmlrpc.server import SimpleXMLRPCServer\n\n\n# 调用函数\ndef respon_string(str):\n    return \"get string:%s\" % str\n\n\nif __name__ == '__main__':\n    server = SimpleXMLRPCServer(('localhost', 8888))  # 初始化\n    server.register_function(respon_string, \"get_string\")  # 注册函数\n    print(\"Listening for Client\")\n    server.serve_forever()  # 保持等待调用状态\n```\n\n\n\n- 客户端\n\n```python\nfrom xmlrpc.client import ServerProxy\n\nif __name__ == '__main__':\n    server = ServerProxy(\"http://localhost:8888\")  # 初始化服务器\n    print(server.get_string(\"cloud\"))  # 调用函数并传参\n```\n\n\n\n### 多线程版\n\n- 服务器端\n\n```python\nfrom xmlrpc.server import SimpleXMLRPCServer\nfrom socketserver import ThreadingMixIn\n\n\nclass ThreadXMLRPCServer(ThreadingMixIn, SimpleXMLRPCServer):\n    pass\n\n\n# 调用函数1\ndef respon_string(str):\n    return \"get string:%s\" % str\n\n\n# 调用函数2\ndef add(x, y):\n    return x + y\n\n\nif __name__ == '__main__':\n    server = ThreadXMLRPCServer(('localhost', 8888))  # 初始化\n    server.register_function(respon_string, \"get_string\")  # 注册函数1\n    server.register_function(add, 'add')  # 注册函数2\n    print(\"Listening for Client\")\n    server.serve_forever()  # 保持等待调用状态\n```\n\n\n\n- 客户端\n\n```python\nfrom xmlrpc.client import ServerProxy\n\nif __name__ == '__main__':\n    server = ServerProxy(\"http://localhost:8888\")  # 初始化服务器\n    print(server.get_string(\"cloud\"))  # 调用函数1并传参\n    print(server.add(8, 8))  # 调用函数2并传参\n```\n\n\n\n### 文件上传下载\n\n- 服务器端\n\n```python\nfrom xmlrpc.server import SimpleXMLRPCServer\nfrom socketserver import ThreadingMixIn\nimport xmlrpc.client\n\n\nclass ThreadXMLRPCServer(ThreadingMixIn, SimpleXMLRPCServer):\n    pass\n\n\n# 供客户端下载文件\ndef image_get():\n    handle = open(\"boy.jpg\", 'rb')\n    return xmlrpc.client.Binary(handle.read())\n\n\n# 供客户端上传文件\ndef image_put(data):\n    handle = open(\"get_girl.jpg\", 'wb')\n    handle.write(data.data)\n    handle.close()\n\n\nif __name__ == '__main__':\n    server = ThreadXMLRPCServer(('localhost', 8888), allow_none=True)  # 初始化\n    server.register_function(image_put, 'image_put')\n    server.register_function(image_get, 'image_get')\n    print(\"Listening for Client\")\n    server.serve_forever()  # 保持等待调用状态\n```\n\n\n\n- 客户端\n\n```python\nfrom xmlrpc.client import ServerProxy\nimport xmlrpc.client\n\nif __name__ == '__main__':\n    server = ServerProxy(\"http://localhost:8888\", allow_none=True)\n    # 上传文件\n    put_handle = open(\"girl.jpg\", 'rb')\n    server.image_put(xmlrpc.client.Binary(put_handle.read()))\n    put_handle.close()\n    # 下载文件\n    get_handle = open(\"get_boy.jpg\", 'wb')\n    get_handle.write(server.image_get().data)\n    get_handle.close()\n```\n\n","tags":["Python"]},{"title":"Markdown语法","url":"/2019/04/02/Markdown语法/","content":"\n## Markdown语法\n\n```\n# 这是一级标题\n## 这是二级标题\n### 这是三级标题\n#### 这是四级标题\n##### 这是五级标题\n###### 这是六级标题\n```\n\n# 这是一级标题\n\n## 这是二级标题\n\n### 这是三级标题\n\n#### 这是四级标题\n\n##### 这是五级标题\n\n###### 这是六级标题\n\n\n\n```\n**这是加粗的文字**\n*这是倾斜的文字*`\n***这是斜体加粗的文字***\n~~这是加删除线的文字~~\n```\n\n**这是加粗的文字**\n*这是倾斜的文字*`\n***这是斜体加粗的文字***\n~~这是加删除线的文字~~\n\n\n\n```\n>这是引用的内容\n>>这是引用的内容\n>>>>>>>>>>这是引用的内容\n```\n\n> 这是引用的内容\n>\n> > 这是引用的内容\n> >\n> > > > > > > > > > 这是引用的内容\n\n\n\n```\n--- 分割线\n----\n***\n*****\n```\n\n------\n\n```\n加入图片\n![]()\n示例：\n![blockchain](https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/\nu=702257389,1274025419&fm=27&gp=0.jpg \"区块链\")\n```\n\n\n\n\n\n```\n[简书](http://jianshu.com)\n[百度](http://baidu.com)\n```\n\n[简书](http://jianshu.com)\n[百度](http://baidu.com)\n\n```\n<a href=\"超链接地址\" target=\"_blank\">超链接名</a>\n\n示例\n<a href=\"https://www.jianshu.com/u/1f5ac0cf6a8b\" target=\"_blank\">简书</a>\n```\n\n<a href=\"https://www.jianshu.com/u/1f5ac0cf6a8b\" target=\"_blank\">简书</a>\n\n```\n- 列表内容\n+ 列表内容\n* 列表内容\n\n注意：- + * 跟内容之间都要有一个空格\n```\n\n- 列表内容\n- 列表内容\n- 列表内容\n\n\n\n```\n1.列表内容\n2.列表内容\n3.列表内容\n\n注意：序号跟内容之间要有空格\n```\n\n1. 列表内容\n2. 列表内容\n3. 列表内容\n\n- ##### 列表嵌套\n\n**上一级和下一级之间敲三个空格即可**\n\n- 一\n- 二\n  - 2.1","tags":["Markdown"]},{"title":"screen的相关用法笔记","url":"/2019/04/02/screen的相关用法笔记/","content":"\n\n\n<a href=\"http://man.linuxde.net/screen\" target=\"_blank\">参考链接</a>\n\n#### screen  \n\nscreen就是开启一个新的终端，利用这个工具可以确保任务不会因为退出某个终端而终止。\n\n\n\n```shell\nscreen  # 输入命令screen会打开一个终端，ctrl+a然后ctrl+d会退出该终端。\n\n[detached from 17799.pts-1.cent01] \n\nscreen\n\n[detached from 17834.pts-1.cent01] \n\nscreen -ls # 列出有哪些screen终端以及他们的编号\n```\n\n```shell\nThere are screens on: \n\n    17834.pts-1.cent01  (Detached) \n\n    17799.pts-1.cent01  (Detached) \n\n    14030.pts-1.cent01  (Detached) \n\n    13942.pts-1.cent01  (Detached) \n\n4 Sockets in /var/run/screen/S-root. \n```\n\n\n\n#### 进入某个screen\n\n```shell\nscreen -r 13942 //进入screen 13942\n```\n\n\n\n#### 创建新的screen\n\n```shell\nscreen -S \"abc\" # 使用-S为一个screen终端命名，避免弄不清哪个终端是什么作用。\n[detached from 17928.abc] \n```\n\n\n\n#### 列举所有screen\n\n```shell\nscreen -ls\n```\n\n```shell\nThere are screens on: \n\n    17928.abc   (Detached) \n\n    17834.pts-1.cent01  (Detached) \n\n    17799.pts-1.cent01  (Detached) \n\n    14030.pts-1.cent01  (Detached) \n\n    13942.pts-1.cent01  (Detached) \n\n5 Sockets in /var/run/screen/S-root. \n```\n\n\n\n#### 关闭某个screen\n\n```shell\nscreen -X -S 21778 quit \n```\n\n\n\n#### 退出某个screen\n\nctrl+a然后ctrl+d会退出该终端。\n\n\n\n#### 清除dead 会话\n\n如果由于某种原因其中一个会话死掉了（例如人为杀掉该会话），这时screen -list会显示该会话为dead状态。使用screen -wipe命令清除该会话：\n\n![](/image/4CD78D32-3E3C-492E-9D92-2B188E4D4054.jpg)\n\n\n\n#### 批量结束进程\n\n```shell\n pkill -9 chromedriver \n```","tags":["shell"]},{"title":"使用github创建自己的博客","url":"/2019/04/01/使用github创建自己的博客/","content":"\n### 一、创建github项目\n\n\n\n- 创建仓库\n\n  访问：https://github.com 注册账号并登陆\n\n  登陆后创建新的仓库，如图：\n\n  ![创建仓库](/image/Jietu20190401-173918@2x-4114526.jpg)\n\n  ![输入地址](/image/Jietu20190401-174202@2x.jpg)\n\n  我这里因为我已经创建了，会提示已经存在，你只需要在这里填上你自己的域名即可，必须以 `github.io` 结尾,前面写上自己的用户名。\n\n  tips：可以同时创建readme，用于介绍项目，也可以不创建。\n\n- 相关设置\n\n  进入setting\n\n  ![setting](/image/Jietu20190401-175029@2x.jpg)\n\n  ![发布](/image/Jietu20190401-175057@2x.jpg)\n\n​\t看到这里就能访问域名了，但显示的是404，因为你还没有配置文件。这里介绍使用hexo创建博客。\n\n### 二、配置ssh\n\n##### 1、按照如下命令创建ssh密钥对\n\n```shell\ncd ~/.ssh\nls\n#此时会显示一些文件\nmkdir key_backup\ncp id_rsa* key_backup\nrm id_rsa*  \n#以上三步为备份和移除原来的SSH key设置\nssh-keygen -t rsa -C \"邮件地址@youremail.com\" #生成新的key文件,邮箱地址填你的Github地址\n#Enter file in which to save the key (/Users/your_user_directory/.ssh/id_rsa):<回车就好>\n#接下来会让你输入密码\n```\n\n##### 2、添加SSH Key到Github\n\n​\t![setting](/image/Jietu20190401-180652@2x.jpg)\n\n​\t![ssh](/image/Jietu20190401-180730@2x.jpg)\n\n​\t![newssh](/image/Jietu20190401-180807@2x.jpg)\n\n​\t![copy](/image/Jietu20190401-180833@2x.jpg)\n\n做到这一步就可以测试一下是否配置成功了:\n\n```shell\nssh -T git@github.com\n#之后会要你输入yes/no,输入yes就好了。\n```\n\n设置账号信息：\n\n```shell\ngit config --global user.name \"你的名字\"     #真实名字不是github用户名\ngit config --global user.email \"邮箱@邮箱.com\"    #github邮箱\n```\n\n\n\n### 三、安装Hexo\n\n​\t要使用Hexo,需要安装Nodejs以及Git\n\n#### 安装Node.js\n\n​\t<a href=\"<https://nodejs.org/en/download/>\" target=\"_blank\">下载Node.js</a>\n\n​\t参考：<a href=\"<http://www.runoob.com/nodejs/nodejs-install-setup.html>\" target=\"_blank\">安装Node.js</a>\n\n#### 安装git\n\n​\t<a href=\"<https://git-scm.com/download/>\" target=\"_blank\">下载git</a>\n\n#### 安装Hexo\n\n\n\n```shell\nnpm install hexo-cli -g   \nhexo init #初始化网站   \nnpm install   \nhexo g #生成或 hexo generate   \nhexo s #启动本地服务器 或者 hexo server,这一步之后就可以通过http://localhost:4000  查看了\n```\n\n*详细命令参考*<a href=\"<https://hexo.io/docs/commands.html>\" target=\"_blank\">Hexo文档</a>\n\n```shell\nhexo new \"文章名\" #新建文章\nhexo new page \"页面名\" #新建页面 \n```\n\n常用简写命令\n\n```shell\nhexo n == hexo new\nhexo g == hexo generate\nhexo s == hexo server\nhexo d == hexo deploy\n```\n\n新建一篇文章后就可以预览了,在hexo new之后执行一次生成hexo g再执行hexo s启动本地服务器,如果之前还在hexo s 按Ctrl + C 结束.\n\n### 四、添加主题\n\n#### 安装主题\n\n到<a href=\"<https://hexo.io/themes/>\" target=\"_blank\">官网</a>等渠道选择主题，下载或clone到本地，放入theme文件夹下\n\n#### 启动主题\n\n找到主目录_config.yml文件，打开并设置属性 theme: <你的主题名字>\n\n![theme](/image/Jietu20190401-181903@2x.jpg)\n\n使用命令生成页面并发布\n\n```shell\nhexo g  # 生成\nhexo s  # 本地访问\n```\n\n发布需要配置_config.yml文件\n\n```shell\ndeploy:\n    type: git\n    repo: git@github.com:pcw1993/pcw1993.github.io.git  #这里的网址填你自己的\n    branch: master\n```\n\n保存后需要提前安装一个扩展：\n\n```shell\nnpm install hexo-deployer-git --save   \n```\n\n发布：\n\n```\nhexo d  # 发布\n```\n\n访问域名即可看到已生成的博客页面"},{"title":"mysql8.0.12重置root密码方法","url":"/2019/04/01/mysql8-0-12重置root密码方法/","content":"@[TOC](mysql8.0.12重置root密码方法)\n\n# 问题\nmysql登录无法连接，问题未知，就是连接不上，报错：\n```\nERROR 1045 (28000): Access denied for user 'root'@'localhost' (using password: YES)\nERROR 1045 (28000): Access denied for user 'root'@'localhost' (using password: NO)\n```\n\n# 解决办法\n## 重置root密码，网上很多错误方法\n```sql\nupdate user set Password=password(\"新密码\") where User='root';\nupdate user set authentication_string=password(\"新密码\") where User='root';\n```\n以上这些，都是错的！！！错的！！！但搜索很多结果都这么写，诚然，以前的版本是这样，但你们标着大大的8.0以后的版本写着这些错误的方法是干嘛？一个个复制粘贴党！！！\n\n经过多次试验，终于找到症结所在，以前的password()函数已经不用了，正确的语句应该是\n```sql\nALTER USER 'root'@'localhost' IDENTIFIED WITH mysql_native_password BY '新密码';\n```\n\n## 完整步骤\n打开终端\n```shell\nmysqld_safe --user=mysql --skip-grant-tables --skip-networking \n// 下面的也是不行的\nmysqld -nt --skip-grant-tables\n```\n再另外打开一个终端窗口\n```sql\nuse mysql;\nALTER USER 'root'@'localhost' IDENTIFIED WITH mysql_native_password BY '新密码';\nflush privileges;\n\\q; //退出\n```\n\n搞定！\n","tags":["mysql"]},{"title":"python使用happybase操作Hbase及Hbase在linux系统下的安装","url":"/2019/02/01/python使用happybase操作Hbase及Hbase在linux系统下的安装/","content":"\n# 安装Hbase\n\n安装请前往Hbase[官方网站](http://mirrors.hust.edu.cn/apache/hbase/)，下载版本根据需求自行选择。bin和src文件都需要下载并解压\n\n```plain\ntar zxvf hbase-x.x.x-bin.tar.gz\n```\n\n![点击并拖拽以移动](data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==)\n\n# 部署jdk并设置java环境 \n\n自行下载jdk并解压到、usr/java中\n\nroot用户下\n\n```plain\nvi .bash_profile\n```\n\n![点击并拖拽以移动](data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==)\n\n写入以下内容\n\n```plain\nexport JAVA_HOME=/usr/java/jdk1.8.0\nexport PATH=$JAVA_HOME/bin:$PATH\nexport CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar\n```\n\n![点击并拖拽以移动](data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==)\n\n执行该文件\n\n```plain\nsource .bash_profile\n```\n\n![点击并拖拽以移动](data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==)\n\n使用命令java -version检查是否安装成功\n\n# 启动和停止HBase \n\nhbase-x.x.x/bin目录下，sh start-hbase.sh”或“./start-hbase.sh”命令启动HBase\n\n出现了以下内容表示启动成功\n\n```plain\nstarting master, logging to /root/zhouzx/hbase-1.0.1/bin/../logs/hbase-root-master-A10168992.out\n```\n\n![点击并拖拽以移动](data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==)\n\nsh stop-hbase.sh”或“./stop-hbase.sh”命令停止HBase\n\n# 安装thrift\n\n## 安装依赖\n\n```plain\nsudo apt-get install automake bison flex g++ git libboost1.55 libevent-dev libssl-dev libtool make pkg-config\n```\n\n![点击并拖拽以移动](data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==)\n\n[下载thrift](https://thrift.apache.org/download)\n\n## 编译安装\n\n```plain\ntar -zxvf thrift-0.11.0.tar.gz\ncd thrift-0.11.0/\n./configure --with-cpp --with-boost --with-python --without-csharp --with-java --without-erlang --without-perl --with-php --without-php_extension --without-ruby --without-haskell  --without-go\nsudo make\nsudo make install\n```\n\n![点击并拖拽以移动](data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==)\n\n## 启动服务\n\n```plain\nbin/hbase-daemon.sh start thrift\n```\n\n![点击并拖拽以移动](data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==)\n\n## 使用jps命令检查服务是否都已启动\n\n```plain\nroot@ubuntu:~/Hbase/hbase-1.4.2# jps\n7393 Jps\n4549 ThriftServer\n7190 HMaster\n2575 Main\n```\n\n![点击并拖拽以移动](data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==)\n\n\n\n# 安装happybase\n\n\n\n所在虚拟环境中\n\n```plain\npip install happybase\n```\n\n![点击并拖拽以移动](data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==)\n\n具体其他用法请参考[happybase文档](https://happybase.readthedocs.io/en/latest/)\n\n```python\nimport happybase\n\n\n\"\"\"\n必须先启动hbase，hbse目录bin/start-hbase.sh\n要先在hbase某个节点上开启thrift服务\n\"\"\"\n\n\n# hbase thrift -p 9090 start\nconnection = happybase.Connection('localhost', autoconnect=False)\nconnection.open()\n\n\n# families = {\n#     'cf1': dict(max_versions=10),\n#     'cf2': dict(max_versions=1, block_cache_enabled=False),\n#     'cf3': dict(),  # use defaults\n# }\n# connection.create_table('mytable', families)\n# connection.create_table('datatest1', )\n\n\n# print所有的表名\nprint('All tables: ', connection.tables(), '\\n')\n\n\n# 操作testtable表\n# 这个操作是一个提前声明-我要用到这个表了-但不会提交给thrift server做操作\ntable = connection.table('mytable')\n\n\n# table.put('row1', {'cf1:content': 'pe', 'cf1:price': '23'})\n# table.put('row2', {'cf1:content': 'pe2', 'cf1:price': '232'})\n\n\n# 检索某一行\nrow = table.row(b'row1')\nprint('a row:', row, '\\n')\n#\n# right\nprint(row[b'cf1:content'])\nprint(row[b'cf1:price'])\n#\n# # wrong,这个是错误的，必须加b\n# print(row['cf1:content'])\n# print(row['cf1:price'])\n#\n# 显示所有列族\nprint('所有列族', table.families(), '\\n')\n#\n# 输出两列\nprint('print two rows:')\nrows = table.rows([b'row1', b'row2'])\nfor key, data in rows:\n    print(key, data)\n#\n# 字典输出两列\nprint('\\n', 'print two dict rows')\nrows_as_dict = dict(table.rows([b'row1', b'row2']))\nprint(rows_as_dict)\n#\n# 输入row的一个列族所有值\nrow = table.row(b'row2', columns=[b'cf1'])\nprint('\\n', '输出一个列族', row)\n#\n# scan操作\nprint('\\n', 'do scan')\nfor key, data in table.scan():\n    print(key, data)\n\n\n\n\n\"\"\"\nAll tables:  [b'mytable']\n\n\na row: {b'cf2:price': b'23', b'cf1:content': b'pe', b'cf1:price': b'23'}\n\n\nb'pe'\nb'23'\n所有列族 {b'cf3': {'block_cache_enabled': False, 'max_versions': 3, 'name': b'cf3:', 'time_to_live': 2147483647, 'bloom_filter_type': b'NONE', 'in_memory': False, 'compression': b'NONE', 'bloom_filter_vector_size': 0, 'bloom_filter_nb_hashes': 0}, b'cf1': {'block_cache_enabled': False, 'max_versions': 10, 'name': b'cf1:', 'time_to_live': 2147483647, 'bloom_filter_type': b'NONE', 'in_memory': False, 'compression': b'NONE', 'bloom_filter_vector_size': 0, 'bloom_filter_nb_hashes': 0}, b'cf2': {'block_cache_enabled': False, 'max_versions': 1, 'name': b'cf2:', 'time_to_live': 2147483647, 'bloom_filter_type': b'NONE', 'in_memory': False, 'compression': b'NONE', 'bloom_filter_vector_size': 0, 'bloom_filter_nb_hashes': 0}}\n\n\nprint two rows:\nb'row1' {b'cf2:price': b'23', b'cf1:content': b'pe', b'cf1:price': b'23'}\nb'row2' {b'cf1:content': b'pe2', b'cf1:price': b'232'}\n\n\n print two dict rows\n{b'row1': {b'cf2:price': b'23', b'cf1:content': b'pe', b'cf1:price': b'23'}, b'row2': {b'cf1:content': b'pe2', b'cf1:price': b'232'}}\n\n\n 输出一个列族 {b'cf1:content': b'pe2', b'cf1:price': b'232'}\n\n\n do scan\nb'row1' {b'cf2:price': b'23', b'cf1:content': b'pe', b'cf1:price': b'23'}\nb'row2' {b'cf1:content': b'pe2', b'cf1:price': b'232'}\n\"\"\"\n```\n\n![点击并拖拽以移动](data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==)","tags":["hbase"]},{"title":"Hello World","url":"/2019/01/02/hello-world/","content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/deployment.html)\n"}]